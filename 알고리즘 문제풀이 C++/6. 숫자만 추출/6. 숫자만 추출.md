# 문제

## 숫자만 추출

문자와 숫자가 섞여있는 문자열이 주어지면 그 중 숫자만 추출하여 그 순서대로 자연수를 만
듭니다. 만들어진 자연수와 그 자연수의 약수 개수를 출력합니다.
만약 “t0e0a1c2her”에서 숫자만 추출하면 0, 0, 1, 2이고 이것을 자연수를 만들면 12가 됩니
다. 즉 첫 자리 0은 자연수화 할 때 무시합니다. 출력은 12를 출력하고, 다음 줄에 12의 약
수의 개수를 출력하면 됩니다.
추출하여 만들어지는 자연수는 100,000,000을 넘지 않습니다.

## 입력설명

첫 줄에 숫자가 썩인 문자열이 주어집니다. 문자열의 길이는 50을 넘지 않습니다.


## 출력설명

첫 줄에 자연수를 출력하고, 두 번째 줄에 약수의 개수를 출력합니다.



## 입력예제 1

```
g0en2Ts8eSoft
```



## 출력예제 1

```
28
6
```


## 풀이


```c++
#include<iostream>

using namespace std;

int main() {
	// 변수선언
	char a[50];
	int num = 0;
	int res = 1;

	// 입력
	cin >> a;

	// 문자, 숫자 판별 후 숫자 저장
	for (int i = 0; a[i]!= '\0'; i++) {
		if (a[i] >= '0' && a[i] <= '9') {
			num = num * 10 + a[i] - '0';
		}
	}
	// 약수 계산
	for (int i = 1; i <= num / 2; i++) {
		if (num % i == 0) {
			res++;
		}
	}

	// 결과 출력
	cout << res;

	return 0;
}
```

## 해설

char의 배열 특성상 항상 마지막에는 '\0'이 들어간다. 이를 이용해 반복문을 '\0'이 나올 때까지 돌려주면 된다.
아스키코드에서의 숫자는 실제 숫자보다 '48'이 더 크다. 따라서 아스키코드에서 '-48'을 해준 뒤 '0 ~ 9' 범위 안에 들어온다면 숫자인 것이다.
* 문자형 0을 뜻하는 '0'을 빼줘도 아스키코드 값에서 48을 빼주는 것과 똑같고, 숫자를 헷갈릴 경우를 줄일 수 있다.
약수를 찾을 때 자기 자신의 절반보다 큰 숫자가 약수인 경우는 자기 자신인 경우밖에 없으므로, 자기 자신의 절반만큼만 약수를 찾게 반복문을 돌려준다.
자기 자신이 약수인 경우를 찾는 반복문이 돌아가지 않기 때문에 약수의 개수를 세는 변수에 1을 먼저 더해준 뒤 카운트한다.